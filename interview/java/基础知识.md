### String能被继承吗
不能，因为他被final修饰

### String底层如何实现 不可变的好处 采用了什么设计模式 字符串常量池
1.8 private final char value[]   
1.9 private final byte value[] 原因是有些字母不需要两个字节
有利于哈希值存储，线程安全，字符串常量池
采用了享元模式

字符串常量池在jdk1.7时被从方法区的运行时常量池移到了堆中的字符串常量池，我们在使用字面量（String s = "string"）创建字符串对象时，
会先在常量池进行查找，如果找到了直接将地址付给s，如果没有找到，那么就会进行创建然后放到常量池中；使用new（String s = new String("string")）
进行创建字符串对象时，也会先在字符串常量池中进行查找，如果找到了，那么会在堆上复制一份副本，然后将堆上的地址赋值给s，如果没有找到那么
会先在常量池中进行创建，然后再进行复制副本到堆上，再赋值给s
总之就是先去查找常量池，先放到常量池

### 基本类型的常量池
整型（包括能自动转成整型的类型）在[-128,127]之间时会使用到常量池

### System.out.print(5+""+10+5)
输出5105，在字符左边的数字会进行计算，在字符串之后就会进行拼接

### switch可以支持哪些参数
在1.7之前只支持int以及可以转换成int的类型，在之后支持了String

### Object有哪些方法
getClass equals hashcode clone wait notify notifyAll finalize toString

### 构造方法可以被哪些修饰
四种修饰类型都可以，但是static final abstract 不可以，而且不可以有返回值

### lambda表达式的优缺点
简洁，调用快
函数是编程，丧失了可读性

### 多态定义 实现机制
在编译期和运行期的类型不一致
重写和重载

### 管理文件和目录的类是什么
File createFile delete isFile exists listFiles isDiractory mkdir getName getPath

### a+=b 和a=a+b的区别
前者会进行强转，后者不会，有可能会报错

### long能不能进行强转成double
不能，可以相反

### 基本类型是如何进行自动转型的
（byte short char）->int ->long->double <-float

### byte数组如何转成String
new String(byte,"utf-8")

### final修饰的变量运算时会不会进行强转
不会

### java可以用哪些进行命名变量
数字 字母 下划线 $ 数字不能开头

### 一个java文件里有多个接口，那么会生成多少个class文件
有多少个接口就会生成多少个class文件

### stream和reader、writer的区别
stream是字节流
reader、writer是字符流
首先创建字节流，然后是文件字节流作为参数来构建字符流，然后就可以进行读写了

### jdbc使用了什么模式
桥接模式
### 类之间存在哪些关系
is-a has-a use-a 关联关系

### jdk jre jvm的区别与联系
jdk：java开发工具，包括了jre
jre：是java的运行环境，其中包含了jvm的标准实现
jvm：java虚拟机

### equals和hashcode的区别
hashcode相同，但是equals不一定相同
equals相同，hashcode一定相同

### 为啥equals重写，必须重写hashcode
比如在set中，如果是equals相同，那么我们就认为他们是同一个对象，所以如果不重写hashcode的话，会被认为是两个对象，会往set里面添加两个相同对象

### final修饰有什么好处
线程安全 共享

### 为什么需要克隆 浅拷贝和深拷贝
clone方法是Object的protect方法
因为直接new的话，没法保存状态 如果是重写clone的话，需要实现clonable
浅拷贝：使用的是和原来的同一个对象
深拷贝：使用的是一个新的对象
不建议使用clone方法进行拷贝，可以使用拷贝工厂的方法进行拷贝，也就是把需要拷贝的对象以参数的形式传入构造函数，构造出一个新的对象

### java的char能存入汉字吗，如果能的话是可以存入所有汉字吗
能，但是并不是全部，因为有些特殊汉字超过了范围

### 注解有什么用
文档，注入属性

### java与C++比较
java没有指针 垃圾自动回收
java面向对象，c++面向过程和对象都可以
java跨平台比c++好
java是解释型语言，C++是编译型语言
java是由C++写的

### 一个文件中main方法可以有多个吗，可以配final，abstract，synchronized修饰吗
可以有多个，属于重载，不可以被abstract修饰，其他的都可以

### 为什么有些接口中没有任何方法
标识接口，主要是标识实现这个类的是一个特定的类型

### 如何实现C语言中指针
可以在接口中进行声明方法

### 面向对象和面向过程的区别
面向对象更符合人的思维，将问题看成一个整体，面向过程则是把问题进行逻辑抽取，使用一个个函数进行处理

### 内部类说一下
成员内部类：可以认为是一个类的成员，可以无条件访问外部类的任何成员变量和成员方法，默认访问的是自己的属性，可以使用`外部类.this.属性`进行访问,
外部类没法直接访问内部类，新建内部类，内部类的创建需要先创建外部类`outer.new inner()`
局部内部类：定义在一个方法类，不能使用修饰符进行修饰，就相当于是一个方法内的变量，作用于仅仅在该方法内
匿名内部类：也就是直接在参数中进行传递的
静态内部类：可以理解为加了static的成员内部类，不依赖于外部类，可以直接进行创建`new Outer.inner`，不能访问外部类的非静态方法

### 反射是什么
反射可以提供运行时的类信息，这个类可以在运行时加载进来，编译时没有的类也可以加载进来。
.class和java.lang.reflact一起对反射提供了支持，这个包下主要有这么几个类，可以通过class对象进行获取出来
Field：可以通过get和set来操作类的属性
Method：可以通过invoke来进行调用
Constructor：可以通过这个来进行创建对象
优点：
可扩展：比如可以在一个类中通过一个类的全限定名来创建一个新的对象
类浏览器和可视化环境：比如一个类浏览器可以查看类的成员，可视化环境比如ide可以使程序员编写出正确的程序
调试器和测试工具：比如调试器需要知道私有成员，还有测试工具可以查看一个类的方法覆盖率
缺点：
性能消耗：反射的性能很差，如果是需要性能比较好的程序的话，那么不建议使用反射
安全限制：必须在安全的环境下进行
内部暴露：因为反射可以访问一些私有的方法，这可能会导致一些问题
反射破坏了面向对象的封装性

### 反射创建类的三种方式
Class.forName() .class getClass()

### 泛型，限制性修饰符和非限制性修饰符？
一个有范围，一个没有范围

### 什么是泛型擦除
就是在编译期使用指定的类进行替换

### 类什么时候会被加载
new以及class.forName
访问静态域
设置静态域的值
静态方法
顶层类中调用了assert
### static？static方法和private方法类能不能被覆盖
类加载时被初始化一次
static不能被覆盖，因为属于静态方法
private方法不能被覆盖，因为被默认修饰为final

### 接口和抽象类如何选择
如果确定不需要属性，那么可以使用接口，不然使用抽象类
一个是is-a关系，一个是like-a关系

### 重载条件？重写条件？
重载：方法名相同，参数列表不同，不看返回值和和修饰符
重写：两同-方法名和参数列表 两小-返回值和异常 一大-修饰符

### 异常分类
Error：非检查异常，程序无法处理
Exception：checked：检查异常，比如文件操作，比如对打开和关闭进行捕获异常 runtime：运行时异常，非检查异常

### 类加载过程？机制？优点？加载器种类
加载-链接-初始化
双亲委派原则
避免重复加载
bootstrap classloader extention classloader application classloader custom classloader

### serialVersionUID作用
对对象序列化进行版本控制

### Comparable和Comparator的区别
重写compareTo
重写compare

### 引用类型？软引用好处？
强引用：new 不会被回收
软引用：new SoftReference<Object>(obj) 内存不足是会被回收
弱引用：new WeakReference<Object>(obj) 只能存活到下一次垃圾回收
虚引用：new Phantomreference<Object>(obj) 相当于不存在，只是在对象被回收时会收到一个通知
提高jvm使用性能
  
### 处理完异常，Exception会发生什么？
会在下一次垃圾回收前回收

### 构造方法能不能被继承
不能

### this()写第一行的原因? super()写第一行的原因? 可以写在一起吗?
表示使用委托构造
验证父类方法是否可用
不可以，是为了防止重复构造

### '0', 'A', 'a', ' ' 的ASCII码是多少
48 65 97 32

### 在Java中unicode占多少字节? UTF-8下中文占多少字节, 英文占多少字节? GBK呢?
2
3 1
2 1

### System.arraycopy() clone() Arrays.copyOf() for性能如何
递减

### cpu寄存器和内存之间会存在什么？如何同步？计算机中是否有堆栈之分？
会存在缓存，也可能是多级缓存，先flush到缓存
没有，堆和栈都可能在任何地方

### 成员变量存储在哪？成员方法中的本地变量呢？static和类本身的一些信息都会存储在哪？
堆 栈 堆

### 线程之间的通信？
共享内存：就是通过内存中的公共状态来进行隐式通信，每个线程都有自己的本地缓存，本地缓存中保存有工作变量的副本
消息通知：在java中的主要就是通过wait和notify进行通信

### 执行控制？内存可见？内存屏障是什么？
就是控制代码的执行顺序以及看是否可以并发执行
线程执行代码时，会先把内存的数据拷贝到本地（cpu缓存），操作完成后再将数据刷到内存
将缓存中的数据强制写入内存

### 自旋锁是目的？偏向锁是啥？
防止线程阻塞造成内核态和用户态切换
偏向第一个访问的线程，认为不会产生资源竞争

### volatile、synchronized、lock有什么区别，以及在哪些场景下使用哪种方式？
synchronized解决的是执行控制的问题，会阻止其他线程拥有该对象的监控锁，从而保证其他线程没法访问该段代码，而且还会创建内存屏障，保证了内存可见
volatile解决的是内存可见问题,对于使用volatile修饰的变量的写那么就直接刷新到内存，读会直接从内存中进行读取
1.volatile只能使用在变量上，synchronized可以使用在变量、方法、类级别
2.volatile只能保证可见性，没法保证原子性，synchronized都可以保证
3.volatile不会造成线程阻塞，synchronized会造成
synchronized是jvm实现的，lock是jdk实现的
性能其实差不多，因为对synchronized进行了很多优化，比如自旋锁
synchronized不可中断，lock可中断
synchronized是非公平的，lock可以是公平的
除非使用lock的高级功能，不然一般都会使用synchronized，因为它是jvm原生支持的，但是lock不是所有的jdk都支持，而且它不用担心锁未释放

### 阻塞队列？

